<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on My Personal Website</title><link>https://fabien.pean.pro/tags/c++/</link><description>Recent content in C++ on My Personal Website</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 07 Oct 2023 00:25:06 +0200</lastBuildDate><atom:link href="https://fabien.pean.pro/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Fastest heterogeneous container and benchmarks</title><link>https://fabien.pean.pro/blog/2020/11/fastest-heterogeneous-container-and-benchmarks/</link><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate><guid>https://fabien.pean.pro/blog/2020/11/fastest-heterogeneous-container-and-benchmarks/</guid><description>&lt;p>While doing some benchmarks with the heterogeneous containers described &lt;a href="https://fabien.pean.pro/blog/2020/07/implementing-an-heterogeneous-dynamic-array-in-cplusplus/">here&lt;/a> and &lt;a href="https://fabien.pean.pro/blog/2020/08/a-simple-heterogeneous-container-in-cplusplus-without-relying-on-variant-nor-any/">here&lt;/a> along with some related containers, I could not but notice the performance of &lt;a href="https://github.com/skypjack/entt">entt&lt;/a>, more specifically its &lt;em>registry&lt;/em> class which relies on a modified sparse set data structure. In front of such witchcraft, I decided to delve behind the curtains and see for myself the performance of an heterogeneous container based on it.&lt;/p>
&lt;h2 id="sparse-sets">Sparse sets&lt;/h2>
&lt;p>Sparse sets are data structures widely covered (&lt;a href="https://programmingpraxis.com/2012/03/09/sparse-sets/">1&lt;/a>, &lt;a href="https://www.geeksforgeeks.org/sparse-set/">2&lt;/a>, &lt;a href="https://skypjack.github.io/2019-09-25-ecs-baf-part-5/">3&lt;/a>, &lt;a href="https://doi.org/10.1145/176454.176484">4&lt;/a>). I will give a shot here and explain succinctly and as clear as possible the concepts behind the data structure.&lt;/p></description></item><item><title>WTF C&amp;plus;&amp;plus;</title><link>https://fabien.pean.pro/notes/wtf-cplusplus/</link><pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate><guid>https://fabien.pean.pro/notes/wtf-cplusplus/</guid><description>&lt;p>In this page, I enumerate various C++ fragments that sparkled my incomprehension when I encountered them, or made me scratch my head far too long. It is meant to be a reminder mainly for myself and destined to be updated over time.&lt;/p></description></item><item><title>A simple heterogeneous container in C&amp;plus;&amp;plus; without relying on 'variant' nor 'any'</title><link>https://fabien.pean.pro/blog/2020/08/a-simple-heterogeneous-container-in-cplusplus-without-relying-on-variant-nor-any/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://fabien.pean.pro/blog/2020/08/a-simple-heterogeneous-container-in-cplusplus-without-relying-on-variant-nor-any/</guid><description>&lt;h2 id="building-an-heterogeneous-container-basic-ingredients">Building an heterogeneous container: basic ingredients&lt;/h2>
&lt;p>In a precedent post, I outlined the implementation of an heterogeneous dynamic array. Let us try now to reflect on what was done to draw some genericity out of it.&lt;/p>
&lt;p>The basic ingredients to build an heterogeneous container are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>data&lt;/code> the object&lt;/li>
&lt;li>&lt;code>ptr&lt;/code> where the object is stored: a pointer or offset allowing to find the object in memory&lt;/li>
&lt;li>&lt;code>tag&lt;/code> what is the type of that object: a unique way to identify types at runtime.&lt;/li>
&lt;li>&lt;code>dtor&lt;/code> how to destroy the object: to avoid memory leaks&lt;/li>
&lt;li>(how to copy the object)&lt;/li>
&lt;/ul>
&lt;p>Numerous implementations can be obtained by combining these components together in various ways. For example, &lt;code>std::any&lt;/code> is basically a structure containing &lt;code>tag&lt;/code>, &lt;code>ptr&lt;/code>, and &lt;code>dtor&lt;/code> together. As such &lt;code>std::any&lt;/code> is self-contained and can be put into a vector without worries. While it is ideal for passing a single item around, having a collection of them is not so great.&lt;/p></description></item><item><title>Implementing an heterogeneous dynamic array in C&amp;plus;&amp;plus;</title><link>https://fabien.pean.pro/blog/2020/07/implementing-an-heterogeneous-dynamic-array-in-cplusplus/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://fabien.pean.pro/blog/2020/07/implementing-an-heterogeneous-dynamic-array-in-cplusplus/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://www.merriam-webster.com/dictionary/heterogeneous">&lt;code>heterogeneous&lt;/code>&lt;/a>: consisting of dissimilar or diverse constituents&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Dynamic_array">&lt;code>dynamic array&lt;/code>&lt;/a>: a dynamic array is a &lt;a href="https://en.wikipedia.org/wiki/Random_access">random access&lt;/a>, variable-size list &lt;a href="https://en.wikipedia.org/wiki/Data_structure">data structure&lt;/a> that allows elements to be added or removed. [&amp;hellip;] A simple dynamic array can be constructed by allocating an array of fixed-size, typically larger than the number of elements immediately required. The elements of the dynamic array are stored contiguously at the start of the underlying array, [&amp;hellip;]&lt;/p>
&lt;/blockquote>
&lt;p>Heterogeneous containers are data structures wherein elements can be of different types. &lt;code>struct&lt;/code> and &lt;code>std::tuple&lt;/code> are example of heterogeneous containers in C++. In contrast, arrays provided by the language or the standard library are homogeneous containers, their elements can only be of the same type. &lt;code>std::array&lt;/code> and &lt;code>std::vector&lt;/code> are examples of static array and dynamic array implementations, respectively.&lt;/p></description></item></channel></rss>