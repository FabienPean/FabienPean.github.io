<!doctype html><html lang=en-us><!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="Fabien Péan"><link rel="shortcut icon" type=image/png href=/img/logo.svg><title>Fabien Péan &#183; Personal Website</title><link rel=stylesheet type=text/css href=/css/normalize.css><link rel=stylesheet href=/vendor/colors/css/colors.min.css><link rel=stylesheet href=/vendor/academicons/css/academicons.min.css><style>:root{--font-monospace: "Source Code Pro";--font-sans-serif:"Inter"}</style><link href="https://fonts.googleapis.com/css?family=Inter%7cSource+Code+Pro&display=swap" rel=stylesheet><link rel=stylesheet href=/css/custom.css></head><body><body><nav id=nav><figure id=logo class=image><img src=/img/logo.svg></figure><div id=branding><div class=branding-title>Fabien Péan</div><div class=branding-subtitle>PhD Student @ ETH Zurich</div></div><div id=menu><a class=menu-link href=/><div class=menu-item><span class=menu-label><i class="fas fa-home fa-fw"></i>&nbsp;Home</span></div></a><a class=menu-link href=/news><div class=menu-item><span class=menu-label><i class="fas fa-newspaper fa-fw"></i>&nbsp;News</span></div></a><a class=menu-link href=/blog><div class=menu-item><span class=menu-label><i class="fas fa-book fa-fw"></i>&nbsp;Blog</span></div></a></div><div class=social><div class=social-list><div style="display:flex;flex-flow:row wrap;justify-content:center"><div class="social-button email"><a href=mailto:fabien@pean.pro rel=author><i class="fas fa-at fa-2x"></i></a></div><div class="social-button bitbucket"><a href=https://bitbucket.org/FabienPean rel="author external"><i class="fab fa-bitbucket fa-2x"></i></a></div><div class="social-button github"><a href=https://github.com/FabienPean rel="author external"><i class="fab fa-github fa-2x"></i></a></div><div class="social-button linkedin"><a href=https://www.linkedin.com/in/FabienPean rel="author external"><i class="fab fa-linkedin fa-2x"></i></a></div></div></div></div></nav><main id=main><div class=content><h1>Implementing an heterogeneous dynamic array in C++</h1><small><div class=subtitle style="display:flex;flex-flow:row wrap;justify-content:space-between"><span style="flex:1 0 auto;max-width:100%"><span>10/07/2020</span>&nbsp;&boxv;&nbsp;<a href=/blog>Blog</a></span><div class=tag-list><a href=/tags/c++><div class=tag>c++</div></a></div></div></small><br><h2 id=introduction>Introduction</h2><blockquote><p><a href=https://www.merriam-webster.com/dictionary/heterogeneous><code>heterogeneous</code></a>: consisting of dissimilar or diverse constituents</p><p><a href=https://en.wikipedia.org/wiki/Dynamic_array><code>dynamic array</code></a>: a dynamic array is a <a href=https://en.wikipedia.org/wiki/Random_access>random access</a>, variable-size list <a href=https://en.wikipedia.org/wiki/Data_structure>data structure</a> that allows elements to be added or removed. [&mldr;] A simple dynamic array can be constructed by allocating an array of fixed-size, typically larger than the number of elements immediately required. The elements of the dynamic array are stored contiguously at the start of the underlying array, [&mldr;]</p></blockquote><p>Heterogeneous containers are data structures wherein elements can be of different types. <code>struct</code> and <code>std::tuple</code> are example of heterogeneous containers in C++. In contrast, arrays provided by the language or the standard library are homogeneous containers, their elements can only be of the same type. <code>std::array</code> and <code>std::vector</code> are examples of static array and dynamic array implementations, respectively.</p><p>In this post, I will outline the implementation of an heterogeneous dynamic array in C++, which satisfies the API below:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>A</span> { <span style=color:#8be9fd>int16_t</span> a0,a1,a2;};
<span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>B</span> { <span style=color:#8be9fd>int32_t</span> b0;};
<span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>C</span> { <span style=color:#8be9fd>int64_t</span> c0;};
HeterogeneousArray ha;
ha.insert(A{<span style=color:#bd93f9>0</span>,<span style=color:#bd93f9>1</span>,<span style=color:#bd93f9>2</span>},B{<span style=color:#bd93f9>404</span>});
ha.insert(C{<span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>});
<span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> b <span style=color:#ff79c6>=</span> ha.get<span style=color:#ff79c6>&lt;</span>B<span style=color:#ff79c6>&gt;</span>();
<span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> a <span style=color:#ff79c6>=</span> ha.get<span style=color:#ff79c6>&lt;</span>A<span style=color:#ff79c6>&gt;</span>();
<span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> c <span style=color:#ff79c6>=</span> ha.get<span style=color:#ff79c6>&lt;</span>C<span style=color:#ff79c6>&gt;</span>();
b.b0<span style=color:#ff79c6>+=</span><span style=color:#bd93f9>42</span>;
a.a0<span style=color:#ff79c6>+=</span>(a.a2<span style=color:#ff79c6>+</span>c.c0);
assert(ha.get<span style=color:#ff79c6>&lt;</span>B<span style=color:#ff79c6>&gt;</span>().b0 <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>446</span>);
assert(ha.get<span style=color:#ff79c6>&lt;</span>A<span style=color:#ff79c6>&gt;</span>().a0 <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>);
</code></pre></td></tr></table></div></div><p>and resulting in the following memory layout:</p><p><img src=heterogeneous_array_intro.svg alt></p><h2 id=motivation>Motivation</h2><p>There are regularly questions or posts popping-up about the existence of an heterogenous container in C++.</p><ul><li><a href=https://gieseanw.wordpress.com/2017/05/03/a-true-heterogeneous-container-in-c/>A true heterogeneous container in C++</a></li><li><a href=https://stackoverflow.com/questions/47768354/c-heterogeneous-container-get-entry-as-type>c++ heterogeneous container, get entry as type</a></li><li><a href=https://www.reddit.com/r/cpp/comments/cniy5y/who_else_would_like_to_see_multitype_lists/>Who else would like to see multi-type lists?</a></li><li><a href=https://www.reddit.com/r/cpp/comments/dnyneq/proof_of_concept_runtime_heterogeneous_containers/>Proof of concept runtime heterogeneous containers</a></li><li><a href=https://www.reddit.com/r/cpp_questions/comments/fjcdvz/multi_type_vectors/>Multi type vectors</a></li><li><a href=https://stackoverflow.com/questions/46651607/is-heterogeneous-array-possible>Is heterogeneous array possible ?</a></li><li><a href=https://stackoverflow.com/questions/45176290/c-heterogeneous-list>C++ Heterogeneous list</a></li><li><a href=https://www.quora.com/How-do-I-create-heterogeneous-containers-in-c-I-want-to-have-different-types-of-elements-in-the-container>How do I create heterogeneous containers in c++? I want to have different types of elements in the container.</a></li><li><a href="https://duckduckgo.com/?q=heterogeneous+array+c%2B%2B">Etc</a></li></ul><p>Answers are often centered around the use of <code>vector&lt;any></code> or <code>vector&lt;variant></code>. However, they each have shortcomings:</p><ul><li>With <code>vector&lt;any></code> solution, <em>any</em> introduces an indirection for each inserted object (vector→any→type) and inserted objects are not stored contiguously, barring special cases (custom allocator).</li><li>With <code>vector&lt;variant></code> solution, <em>variant</em> requires the user to provide a list of types known at compile-time. Moreover, memory is inherently wasted because the size of a variant is the size of the largest possible type it can hold, plus some extra for the type identifier.</li></ul><p>In <a href=https://gieseanw.wordpress.com/2017/05/03/a-true-heterogeneous-container-in-c/>&ldquo;A true heterogeneous container in C++&rdquo;</a>, the container relies on a static member variable to store/retrieve the inserted/requested objects, using the memory address of the container itself as a key in a map:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>andyg_hc</span> {
	<span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>T</span><span style=color:#ff79c6>&gt;</span>
	<span style=color:#ff79c6>static</span> std<span style=color:#ff79c6>::</span>unordered_map<span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>const</span> andyg_hc<span style=color:#ff79c6>*</span>, std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;&gt;</span> items;
    <span style=color:#6272a4>/* Etc */</span>
};
</code></pre></td></tr></table></div></div><p>The API is pleasant, but only instances of a same type are stored contiguously, which favors fast per-type linear iteration. As noted by its author, it has some drawbacks making it ill-suited beyond an experimental usage.</p><p>The layout provided by these solution is<br><img src=comparison_containers.svg alt></p><p>I was left bugged by these solutions, so I decided to explore the feasibility of having a class that has the semantics of an heterogeneous vector/a structure populated at runtime. Basically, a contiguous piece of memory (one indirection) where any object can be inserted one after another. I used this exercise as a good opportunity to experiment with C++17 meta-programming features and low-level memory manipulation. Beware, knowledge of <a href=https://en.cppreference.com/w/cpp/language/parameter_pack>variadic templates</a> and <a href=https://en.cppreference.com/w/cpp/language/fold>fold-expressions</a> is highly recommended in the following. Let&rsquo;s now see that together !</p><h2 id=principle>Principle</h2><h3 id=for-a-bit-there-were-only-bytes>For a bit, there were only bytes</h3><p>We will have to manipulate and manage directly the memory in order to perform our goal. Since we want the least amount of indirection while remaining extensible, the best is to store everything inside an array of bytes on the heap. This member will hold the actual instances of our objects.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>using</span> allocator <span style=color:#ff79c6>=</span> <span style=color:#6272a4>/*for later*/</span>;
std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>std<span style=color:#ff79c6>::</span>byte,allocator<span style=color:#ff79c6>&gt;</span> data;
</code></pre></td></tr></table></div></div><h3 id=know-your-style>Know your style</h3><p>With this single member, only the caller who inserted the object would know <em>what</em> is <em>where</em>. Type information is lost and our heterogenous array is far from being self-contained. Indeed, there would be no way to access its content solely with a reference to the container. Thus, we add a member that keeps track of <em>what</em> is <em>where</em>.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>using</span> typeid_t <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span><span style=color:#8be9fd>uint32_t</span>;
<span style=color:#ff79c6>using</span> offset_t <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span><span style=color:#8be9fd>uint32_t</span>;
std<span style=color:#ff79c6>::</span>unordered_map<span style=color:#ff79c6>&lt;</span>typeid_t,offset_t<span style=color:#ff79c6>&gt;</span> type_to_offset;
</code></pre></td></tr></table></div></div><p>Values represented by <code>typeid_t</code> uniquely identify a type at runtime and those represented by <code>offset_t</code> give the memory offset where the instance of a type is located in <code>data</code>.</p><p>Since C++14, it is possible to have a unique value assigned to a type easily thanks to a <a href=https://en.cppreference.com/w/cpp/language/variable_template>variable template</a>. The implementation holds in a few lines of code:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TypeCounter</span> {
    <span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> typeid_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
<span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
    <span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
    <span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span> id <span style=color:#ff79c6>=</span> i<span style=color:#ff79c6>++</span>;
};
<span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>auto</span> type_id() { <span style=color:#ff79c6>return</span> TypeCounter<span style=color:#ff79c6>::</span>id<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>; }
</code></pre></td></tr></table></div></div><h3 id=in-order-to-get-you-must-give>In order to get, you must give</h3><p>We now have the minimum necessary members to implement insertion into the container. It consists of allocating needed memory first, then constructing the object within that space and finally doing some bookkeeping (record <em>what</em> was stored <em>where</em>).</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span>... Types<span style=color:#ff79c6>&gt;</span>
<span style=color:#ff79c6>auto</span> insert(Types<span style=color:#ff79c6>&amp;&amp;</span>... types) {
    <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span> offsets <span style=color:#ff79c6>=</span> allocate<span style=color:#ff79c6>&lt;</span>Types...<span style=color:#ff79c6>&gt;</span>();           <span style=color:#6272a4>//allocate
</span><span style=color:#6272a4></span>    {size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; (construct(offsets[i<span style=color:#ff79c6>++</span>],types), ...);}<span style=color:#6272a4>//construct
</span><span style=color:#6272a4></span>    {size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; (typeid_to_offset.emplace(type_id<span style=color:#ff79c6>&lt;</span>Types<span style=color:#ff79c6>&gt;</span>(),offsets[i<span style=color:#ff79c6>++</span>]), ...);}<span style=color:#6272a4>//bookkeeping
</span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> offsets;
}
</code></pre></td></tr></table></div></div><p>Allocation is the most involved task. It must compute the new size needed to hold the desired content, resize accordingly, while computing the position where each object should be constructed. The easy but wrong solution would be to resize <code>data</code> solely with the additional storage needed by each inserted type:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#6272a4>// ❌ Don&#39;t do this ❌
</span><span style=color:#6272a4></span><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span>... Ts<span style=color:#ff79c6>&gt;</span>
<span style=color:#ff79c6>auto</span> allocate() {
    <span style=color:#ff79c6>constexpr</span> <span style=color:#ff79c6>auto</span> N <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>...(Ts);
    <span style=color:#ff79c6>constexpr</span> <span style=color:#ff79c6>auto</span> sizes <span style=color:#ff79c6>=</span> array<span style=color:#ff79c6>&lt;</span>size_t, N<span style=color:#ff79c6>&gt;</span>{ <span style=color:#ff79c6>sizeof</span>(Ts)... };

    std<span style=color:#ff79c6>::</span>array<span style=color:#ff79c6>&lt;</span>offset_t, N<span style=color:#ff79c6>&gt;</span> output;
    output[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>=</span> data.size();
    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>; i<span style=color:#ff79c6>&lt;</span>N; <span style=color:#ff79c6>++</span>i) {
        output[i] <span style=color:#ff79c6>=</span> output[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>+</span> sizes[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]; 
    }
    <span style=color:#ff79c6>constexpr</span> size_t to_add <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>sizeof</span>(Ts)<span style=color:#ff79c6>+</span>...<span style=color:#ff79c6>+</span><span style=color:#bd93f9>0</span>);
    data.resize(data.size() <span style=color:#ff79c6>+</span> to_add);
    <span style=color:#ff79c6>return</span> output;
}
</code></pre></td></tr></table></div></div><p>Repeat after me: <a href=https://en.wikipedia.org/wiki/Data_structure_alignment><em>padding is a thing</em></a>, <a href=https://developer.ibm.com/technologies/systems/articles/pa-dalign/><em>padding is a thing</em></a>, <a href=https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt><em>padding is a thing</em></a>. It also works with <em>alignment my torment</em> 🎵 depending on your history with the topic. In brief, objects cannot reside wherever they want in memory, and their memory addresses are restricted to be dividable by some values (a power of 2). For example, <code>std::uint16_t</code> has a size and alignment of 2 bytes, then the least significant bit in its memory address will always be 0 (i.e. memory address is an even number).</p><p>In general, the alignment and padding within user-defined structures are automatically set by the compiler. It ensures that each structure members will be properly aligned in regular scenarios. However, we cannot rely here on the compiler to do it because objects are constructed in a piece of memory only appearing as an array of bytes. Hence, we have to compute the padding for each object ourselves and take them into account when resizing the container.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span>... Types<span style=color:#ff79c6>&gt;</span>
<span style=color:#ff79c6>auto</span> allocate() {
    <span style=color:#ff79c6>using</span> <span style=color:#ff79c6>namespace</span> std;
    <span style=color:#ff79c6>constexpr</span> size_t N <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>...(Types);
    <span style=color:#ff79c6>constexpr</span> array<span style=color:#ff79c6>&lt;</span>size_t, N<span style=color:#ff79c6>&gt;</span> alignments <span style=color:#ff79c6>=</span> { <span style=color:#ff79c6>alignof</span>(Types)... };
    <span style=color:#ff79c6>constexpr</span> array<span style=color:#ff79c6>&lt;</span>size_t, N<span style=color:#ff79c6>&gt;</span> sizes <span style=color:#ff79c6>=</span> { <span style=color:#ff79c6>sizeof</span>(Types)... };
    
    array<span style=color:#ff79c6>&lt;</span>offset_t, N<span style=color:#ff79c6>&gt;</span> output;
    
    <span style=color:#ff79c6>const</span> size_t size_before <span style=color:#ff79c6>=</span> data.size();
    uintptr_t ptr_end <span style=color:#ff79c6>=</span> uintptr_t(data.data() <span style=color:#ff79c6>+</span> size_before);
    size_t to_allocate <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>; i<span style=color:#ff79c6>&lt;</span>N; <span style=color:#ff79c6>++</span>i) 
    {
        <span style=color:#ff79c6>const</span> size_t padding <span style=color:#ff79c6>=</span> ((<span style=color:#ff79c6>~</span>ptr_end <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>&amp;</span> (alignments[i] <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>));
        output[i] <span style=color:#ff79c6>=</span> size_before <span style=color:#ff79c6>+</span> to_allocate <span style=color:#ff79c6>+</span> padding;
        to_allocate <span style=color:#ff79c6>+=</span> padding <span style=color:#ff79c6>+</span> sizes[i];
        ptr_end <span style=color:#ff79c6>+=</span> padding <span style=color:#ff79c6>+</span> sizes[i];
    }
    data.resize(size_before <span style=color:#ff79c6>+</span> to_allocate);
    <span style=color:#ff79c6>return</span> output;
}
</code></pre></td></tr></table></div></div><p>You may raise a serious warning here: &ldquo;ok, newly inserted objects are properly padded with respect to <em>current</em> end address (<code>ptr_end</code>), but resizing the vector may provoke a reallocation, thus destroying the memory alignment since we have no guarantee that the vector would put everything at a same memory ending!&rdquo; *catch up breath* Fine observation, you are right !</p><p>Obtaining properly aligned memory manually could be achieved, accepting a waste of <em>alignment value</em> bytes. New facilities were added in C++17 to deal with alignment in dynamic memory allocation. For example, the alignment value can be explicitly provided during dynamic memory allocation via additional overload to <a href=https://en.cppreference.com/w/cpp/memory/new/operator_new><code>new</code></a>. Alas, this is <a href=https://www.bfilipek.com/2019/08/newnew-align.html>not yet (ever?) portable</a> due to how each OS deals with aligned memory allocation. To keep it simple, we make use of the <a href=https://www.boost.org/doc/libs/1_73_0/doc/html/align.html>Boost.Align</a> library, which provides an allocator that can force our array of bytes to always be aligned on a specific value.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>constexpr</span> <span style=color:#ff79c6>auto</span> max_alignment <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>64UL</span>;
<span style=color:#ff79c6>using</span> allocator <span style=color:#ff79c6>=</span> boost<span style=color:#ff79c6>::</span>aligned_allocator<span style=color:#ff79c6>&lt;</span>std<span style=color:#ff79c6>::</span>byte,max_alignment<span style=color:#ff79c6>&gt;</span>;
</code></pre></td></tr></table></div></div><p>Consequently, every type whose alignment is lower or equal than <code>max_alignment</code> is guaranteed to be properly aligned within the buffer, even after memory relocation. For security, we could add the following check to guarantee no type inserted in the container has a higher alignment than the arbitrary chosen one.</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>static_assert</span>(((<span style=color:#ff79c6>alignof</span>(T) <span style=color:#ff79c6>&lt;=</span> max_alignment) <span style=color:#ff79c6>&amp;&amp;</span> ...));
</code></pre></td></tr></table></div></div><p>Now that allocation is finally correctly done, we can construct our instance within the resized <code>data</code>. For this purpose, in-place constructor suffices. Phew !</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> Type<span style=color:#ff79c6>&gt;</span>
<span style=color:#8be9fd>void</span> construct(offset_t n, Type<span style=color:#ff79c6>&amp;&amp;</span> t) {
    <span style=color:#ff79c6>using</span> U <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>remove_reference_t<span style=color:#ff79c6>&lt;</span>Type<span style=color:#ff79c6>&gt;</span>;
    <span style=color:#ff79c6>new</span>(<span style=color:#ff79c6>&amp;</span>data[n]) U{ std<span style=color:#ff79c6>::</span>forward<span style=color:#ff79c6>&lt;</span>Type<span style=color:#ff79c6>&gt;</span>(t) };
}
</code></pre></td></tr></table></div></div><h3 id=you-shall-have-the-aptitude-to-get>You shall have the aptitude to get</h3><p>The procedure to retrieve a reference from the container is conceptually straightforward. We lookup where the type is stored and cast the bytes starting from that address as a reference to the desired type, which we know is there. This implies the use of <code>reinterpret_cast</code>. Unfortunately, C++ is quite unforgiving when one attempts to mess the type system. If the reference is a structure/class which has some members, any end-user that attempts to access a member would trigger <a href=https://en.cppreference.com/w/cpp/language/ub>Undefined Behavior</a>, which conveniently rhymes with Unexpected Bug.</p><blockquote><p>From <a href=https://en.cppreference.com/w/cpp/language/reinterpret_cast><code>reinterpret_cast</code></a></p><p>Performing a class member access that designates a non-static data member or a non-static member function on a glvalue that does not actually designate an object of the appropriate type - such as one obtained through a reinterpret_cast - results in undefined behavior:</p></blockquote><p>A way to get around this safely was introduced in C++17 with <a href=https://en.cppreference.com/w/cpp/utility/launder><code>std::launder</code></a>. One of the example given on <a href=https://en.cppreference.com/w/cpp/utility/launder>cppreference</a> fits exactly our situation:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>Y</span> { <span style=color:#8be9fd>int</span> z; };
<span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>()
{
  <span style=color:#ff79c6>alignas</span>(Y) std<span style=color:#ff79c6>::</span>byte s[<span style=color:#ff79c6>sizeof</span>(Y)];
  Y<span style=color:#ff79c6>*</span> q <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span>(<span style=color:#ff79c6>&amp;</span>s) Y{<span style=color:#bd93f9>2</span>};
  <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span> f <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>reinterpret_cast</span><span style=color:#ff79c6>&lt;</span>Y<span style=color:#ff79c6>*&gt;</span>(<span style=color:#ff79c6>&amp;</span>s)<span style=color:#ff79c6>-&gt;</span>z; <span style=color:#6272a4>// Class member access is undefined behavior:
</span><span style=color:#6272a4></span>                                             <span style=color:#6272a4>// reinterpret_cast&lt;Y*&gt;(&amp;s) has value &#34;pointer to s&#34;
</span><span style=color:#6272a4></span>                                             <span style=color:#6272a4>// and does not point to a Y object 
</span><span style=color:#6272a4></span>  <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>int</span> g <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>launder(<span style=color:#ff79c6>reinterpret_cast</span><span style=color:#ff79c6>&lt;</span>Y<span style=color:#ff79c6>*&gt;</span>(<span style=color:#ff79c6>&amp;</span>s))<span style=color:#ff79c6>-&gt;</span>z; <span style=color:#6272a4>// OK
</span><span style=color:#6272a4></span>}
</code></pre></td></tr></table></div></div><p>Finally, the method for accessing the content of the container is:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span>... T<span style=color:#ff79c6>&gt;</span>
<span style=color:#ff79c6>auto</span> get() <span style=color:#ff79c6>-&gt;</span> <span style=color:#ff79c6>decltype</span>(<span style=color:#ff79c6>auto</span>) {
    <span style=color:#ff79c6>if</span> <span style=color:#50fa7b>constexpr</span>(<span style=color:#ff79c6>sizeof</span>...(T)<span style=color:#ff79c6>==</span><span style=color:#bd93f9>1</span>)
        <span style=color:#ff79c6>return</span> (get<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>(type_to_offset.at(type_id<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>())),...);
    <span style=color:#ff79c6>else</span>
        <span style=color:#ff79c6>return</span> std<span style=color:#ff79c6>::</span>tuple<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&amp;</span>...<span style=color:#ff79c6>&gt;</span>{ get<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>(type_to_offset.at(type_id<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>()))... };	
}
<span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T, <span style=color:#ff79c6>typename</span> U <span style=color:#ff79c6>=</span> std<span style=color:#ff79c6>::</span>remove_reference_t<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;&gt;</span>
U<span style=color:#ff79c6>&amp;</span> get(offset_t n) {
    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>*</span>std<span style=color:#ff79c6>::</span>launder(<span style=color:#ff79c6>reinterpret_cast</span><span style=color:#ff79c6>&lt;</span>U<span style=color:#ff79c6>*&gt;</span>(<span style=color:#ff79c6>&amp;</span>data[n]));
}
</code></pre></td></tr></table></div></div><p>Neither <code>auto&</code> or <code>auto&&</code> would be warning/error-free because the method either returns a reference (<code>T&</code>) or a value (<code>std::tuple&lt;T&...></code>). As a result, the more obscure <code>decltype(auto)</code> is necessary, which infers the proper return type.</p><h3 id=no-leeks-in-my-cup-of-tea>No leeks in my cup of tea</h3><p>For a basic implementation to be minimally correct, we must properly resolve the destruction of the container. If it were left with a default destructor, any object in the container that allocated on the heap would leak its memory. Once again, this is the result of our manual management of the memory. Since the compiler only sees an array of bytes and not the underlying types, it will not call the destructors of inserted objects. As a result, we must deal with them explicitly:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#ff79c6>using</span> destructor_t <span style=color:#ff79c6>=</span> <span style=color:#8be9fd>void</span>(<span style=color:#ff79c6>*</span>)(HeterogeneousArray<span style=color:#ff79c6>&amp;</span>);
std<span style=color:#ff79c6>::</span>unordered_map<span style=color:#ff79c6>&lt;</span>type_id_t, destructor_t<span style=color:#ff79c6>&gt;</span> destructors;

<span style=color:#ff79c6>~</span>HeterogeneousArray() {
    <span style=color:#ff79c6>for</span> (<span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> [tid, destructor] <span style=color:#ff79c6>:</span> destructors)
        destructor(<span style=color:#ff79c6>*</span><span style=color:#ff79c6>this</span>);
}
<span style=color:#ff79c6>template</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
<span style=color:#8be9fd>void</span> record_destructor() {
    destructors.emplace(type_id<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>(), <span style=color:#ff79c6>+</span>[](HeterogeneousArray<span style=color:#ff79c6>&amp;</span> c) { std<span style=color:#ff79c6>::</span>destroy_at(<span style=color:#ff79c6>&amp;</span>c.get<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;</span>()); });
}
<span style=color:#6272a4>// Update
</span><span style=color:#6272a4></span><span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>insert</span>(Types<span style=color:#ff79c6>&amp;&amp;</span>... types) {
    <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span> offsets <span style=color:#ff79c6>=</span> allocate<span style=color:#ff79c6>&lt;</span>Types...<span style=color:#ff79c6>&gt;</span>();
    {size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; (construct(offsets[i<span style=color:#ff79c6>++</span>],types), ...);}
    {size_t i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; (type_to_offset.emplace(type_id<span style=color:#ff79c6>&lt;</span>Types<span style=color:#ff79c6>&gt;</span>(),offsets[i<span style=color:#ff79c6>++</span>]), ...);}
    (record_destructor<span style=color:#ff79c6>&lt;</span>Types<span style=color:#ff79c6>&gt;</span>(), ...);<span style=color:#6272a4>//🆕
</span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> offsets;
}
</code></pre></td></tr></table></div></div><h2 id=conclusion>Conclusion</h2><p>A minimal working implementation of an heterogeneous dynamic array has been described and it holds in less than a 100 lines of code ! 😮 See for yourself on <a href=https://godbolt.org/z/3aP5rY>Compiler Explorer</a>. The main restriction of the current implementation is that it only accepts a single instance of each type. Furthermore, several features could be added on top of it to make it more efficient and user-friendly:</p><ul><li>Copy/move construction/assignment of the container</li><li>Insertion that does not require the type to be move/copy constructible, <em>à la</em> emplace</li><li>Reduce memory waste when inserting several types in a single call</li><li>Avoid storing empty types</li><li>Avoid storing trivial destructors</li><li>Provide additional methods for retrieving offsets type identifier, or checking presence</li></ul><p>In a follow-up post, the performance of the implementation will be compared to some alternatives.</p><h2 id=acknowledgment>Acknowledgment</h2><p>Thanks <a href=https://www.linkedin.com/in/starkovr>Rasti</a> for the diligent review !</p></div></main><footer id=footer><div id=footer-inner>&copy;&nbsp;2020&nbsp;&#183;&nbsp;Fabien Péan</div></footer><script>window.FontAwesomeConfig={searchPseudoElements:true}</script><script async src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin=anonymous></script><script async defer src=https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.6.0/clipboard.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js integrity="sha256-lyWCDMnMeZiXRi7Zl54sZGKYmgQs4izcT7+tKc+KUBk=" crossorigin=anonymous></script><script>mermaid.initialize({startOnLoad:true,securityLevel:'loose',theme:'default',themeCSS:'',cloneCssStyles:true,useMaxWidth:true,htmlLabels:false,flowchart:{curve:'basis'}});</script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:false,processEnvironments:true},svg:{fontCache:'global'}};</script><script async type=text/javascript id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script src=/js/custom.js></script></body></html>